<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>decoration vector graphics</title>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/2.0.0/modern-normalize.min.css"
    />
    <link rel="stylesheet" href="./style/style.css" />
  </head>

  <body class="body">
    <header class="header">
      <div class="container">
        <h3 class="title">Псевдоэлементы</h3>

        <p>
          Псевдоэлементы <b>::before</b> и <b>::after</b> используются для
          добавления декоративных эффектов (иконок, плашек, оверлеев) без
          необходимости создания дополнительных пустых тегов в разметке.
        </p>
        <ul>
          <li>
            <b>::before</b> - создаёт псевдоэлемент <b>перед</b> всем контентом
            элемента (в начале).
          </li>
          <li>
            <b>::after</b> - создаёт псевдоэлемент <b>после</b> всего контента
            элемента (в конце).
          </li>
        </ul>
        <div class="bg">
          <p>
            .box { <br />

            /* стили элемента */ <br />
            } <br /><br />
            .box::before { <br />
            /* стили псевдоэлемент before */ <br />
            } <br /><br />.box::after { <br />/* стили псевдоэлемент after */
            <br />
            }
          </p>
        </div>
        <p class="information">
          По умолчанию это строчные элементы. Для того, чтобы задать
          псевдоэлементу вертикальную геометрию, необходимо изменить его тип на
          блочный или, что чаще всего, строчно-блочный.
        </p>
        <h3 class="title">Свойство content</h3>
        <p>
          Это обязательное свойство позволяет добавить текстовый контент внутрь
          псевдоэлемента. Даже если текстовый контент не нужен, его значением
          необходимо поставить пустую строку, иначе браузер просто не создаст
          псевдоэлемент.
        </p>
        <div class="bg">
          <p>
            &lt;div class=&quot;box&quot;&gt; <br />
            Lorem, ipsum dolor sit amet consectetur adipisicing elit. Officia
            itaque quia nobis fugit amet adipisci, corrupti animi, iusto eius a
            sed totam voluptas porro. Dolorem aliquid rerum magnam eligendi
            aspernatur. <br />
            &lt;/div&gt;
          </p>
        </div>
        <p>
          В селекторе можно использовать только один псевдоэлемент, который
          должен добавляться после простого селектора (тега, класса,
          идентификатора).
        </p>
        <div class="bg">
          <p>
            .box::before { <br />
            content: 'Это текст в ::before'; <br />
            font-size: 40px; <br />
            color: orange; <br />
            } <br /><br />
            .box::after { <br />
            content: 'Это текст в ::after';<br />
            font-size: 30px; color: teal;<br />
            }
          </p>
        </div>
        <p class="warning">
          Не используйте псевдоэлементы для добавления текстового контента, это
          грубое нарушение спецификации, они служат исключительно для
          декоративного оформления. Текст внутри псевдоэлемента не
          воспринимается ассистивными технологиями и индексаторами, а также
          будет недоступен пользователю если не загрузится файл стилей.
        </p>
        <h3 class="title">Псевдокласс :hover</h3>
        <p>
          Для того, чтобы изменить стили псевдоэлемента при событии на
          родительском элементе, например ховер, необходимо использовать
          следующий селектор.
        </p>
        <div class="bg">
          <p>
            /* Применить стили к псевдоэлементу .box::before при ховере по
            элементу .box */ <br />
            .box:hover::before { <br />
            color: green; <br />
            } <br /><br />

            /* Применить стили к псевдоэлементу .box::after при ховере по
            элементу .box */ <br />
            .box:hover::after { <br />
            color: tomato;<br />
            }
          </p>
        </div>
        <h3 class="title">Псевдоэлемент-иконка</h3>
        <p>
          Используя псевдоэлементы добавим иконки перед и после ссылками в
          списке. Пусть ::before будет виден всегда, а ::after только при ховере
          по ссылке.
        </p>

        <ul class="list">
          <li class="list-item">
            <a href="" class="list-link">Home</a>
          </li>
          <li class="list-item">
            <a href="" class="list-link">Portfolio</a>
          </li>
          <li class="list-item">
            <a href="" class="list-link">Team</a>
          </li>
          <li class="list-item">
            <a href="" class="list-link">About</a>
          </li>
        </ul>
        <p>
          Самое важное находится в этом <b>CSS-правиле</b>. Изменяем тип
          элемента на строчно-блочный и задаём фиксированную высоту и ширину.
          Также не забываем указать свойство content с пустой строкой, чтобы
          браузер создал псевдоэлемент.
        </p>
        <div class="bg">
          <p>
            .list-link::before, <br />
            .list-link::after { <br />
            content: ''; <br />
            display: inline-block; <br />
            width: 24px; <br />
            height: 24px; <br />
            }
          </p>
        </div>
        <div class="overlay"></div>

        <h3 class="title">Тень элемента</h3>
        <p>
          Тень добавляет элементу эффект объёмности и ощущение высоты. Тени
          бывают внешние и внутренние, размытые и плоские, одинарные и
          многослойные.
        </p>
        <div class="bg">
          <img src="./images/shadow.jpg" />
        </div>
        <p>
          Свойство <b>box-shadow</b> задаёт элементу одну или более теней. По
          умолчанию размер тени совпадает с размером элемента, а её цвет такой
          же как цвет его текста.
        </p>
        <div class="bg">
          <p>
            <b>box-shadow:</b> &lt;x-offset&gt; &lt;y-offset&gt; &lt;blur&gt;
            &lt;spread&gt; &lt;color&gt;
          </p>
        </div>
        <ul>
          <li>
            <b>x-offset</b> - горизонтальное смещение. Положительное значение
            смещает тень вправо от блока, отрицательное – влево. Обязательное
            значение.
          </li>
          <li>
            <b>y-offset</b> - вертикальное смещение. Положительное значение
            смещает тень вниз, отрицательное - вверх. Обязательное значение.
          </li>
          <li>
            <b>blur</b> - радиус размытия. Чем больше значение, тем сильнее
            размыта тень. Необязательное значение.
          </li>
          <li>
            <b>spread</b> - радиус распространения. Положительное значение
            увеличивает тень, отрицательное - уменьшает. Необязательное
            значение.
          </li>
          <li>
            <b>color</b> - цвет тени. Можно использовать любой формат записи
            цвета. Необязательное значение.
          </li>
        </ul>
        <div class="shadow">
          <h4>Lorem ipsum dolor sit amet.</h4>
          <p>
            Lorem ipsum, dolor sit amet consectetur adipisicing elit. Vero,
            error quisquam. Numquam minima sed amet officia dolore
            necessitatibus at velit optio, commodi natus? Necessitatibus
            consequatur autem veniam ipsam quis quisquam similique delectus
            nulla, atque eaque itaque quas. Maxime quisquam explicabo itaque
            doloremque recusandae, eos necessitatibus quis deleniti reiciendis
            consectetur? Neque.
          </p>
        </div>
        <div class="card__set">
          <article class="post">
            <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
            <p class="post__text">
              Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptas
              id eius sunt quas eos accusantium! Pariatur alias reiciendis
              nesciunt fuga repellat aperiam, omnis eligendi.
            </p>
          </article>

          <article class="post">
            <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
            <p class="post__text">
              Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptas
              id eius sunt quas eos accusantium! Pariatur alias reiciendis
              nesciunt fuga repellat aperiam, omnis eligendi.
            </p>
          </article>

          <article class="post">
            <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
            <p class="post__text">
              Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptas
              id eius sunt quas eos accusantium! Pariatur alias reiciendis
              nesciunt fuga repellat aperiam, omnis eligendi.
            </p>
          </article>

          <article class="post">
            <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
            <p class="post__text">
              Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptas
              id eius sunt quas eos accusantium! Pariatur alias reiciendis
              nesciunt fuga repellat aperiam, omnis eligendi.
            </p>
          </article>
        </div>
        <h3 class="title">Внутренняя тень</h3>
        <p>
          Если внешняя тень визуально приподнимает элемент, то внутренняя тень
          позвоялет добавить эффект глубины, вдавливая элемент в интерфейс.
          Синтаксис объявления внутренней тени аналогичен обычной, но первым
          значением необходимо указать <b>inset</b>.
        </p>
        <div class="bg">
          <p>
            <b>box-shadow:</b> inset &lt;x-offset&gt; &lt;y-offset&gt;
            &lt;blur&gt; &lt;spread&gt; &lt;color&gt;
          </p>
        </div>
        <p>
          Смещение, размытие и распространение тени происходит внутри элемента и
          визуально ограничено его рамкой.
        </p>

        <article class="post__inset">
          <h1 class="post__title-inset">Lorem ipsum dolor sit amet</h1>
          <p class="post__text-inset">
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptas id
            eius sunt quas eos accusantium! Pariatur alias reiciendis nesciunt
            fuga repellat aperiam, omnis eligendi. Ut accusantium ea molestias
            totam eum harum facere adipisci placeat reiciendis, consequatur aut
            officia non obcaecati dolor quia laboriosam consequuntur odio, sed
            sint fuga nam.
          </p>
        </article>

        <h3 class="title">Многослойная тень</h3>
        <p>
          На один элемент можно добавить несколько теней, указав их через
          запятую.
        </p>
        <div class="bg">
          <p>
            <b>box-shadow:</b> <br />
            &lt;x-offset&gt; &lt;y-offset&gt; &lt;blur&gt; &lt;spread&gt;
            &lt;color&gt;,<br />
            &lt;x-offset&gt; &lt;y-offset&gt; &lt;blur&gt; &lt;spread&gt;
            &lt;color&gt;, <br />
            &lt;x-offset&gt; &lt;y-offset&gt; &lt;blur&gt; &lt;spread&gt;
            &lt;color&gt;, <br />
            ...
          </p>
        </div>
        <p>
          Получается многослойный пирог, в котором первая тень в списке
          размещается на самом верху, последняя - в самом низу. То есть, чем
          раньше указана тень, тем выше она в слоях, и будет визуально
          перекрывать все последующие. Этот подход позволяет сделать очень
          мягкие и красивые тени.
        </p>
        <article class="post__shadow">
          <h1 class="post__title">Lorem ipsum dolor sit amet</h1>
          <p class="post__text">
            Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptas id
            eius sunt quas eos accusantium! Pariatur alias reiciendis nesciunt
            fuga repellat aperiam, omnis eligendi. Ut accusantium ea molestias
            totam eum harum facere adipisci placeat reiciendis, consequatur aut
            officia non obcaecati dolor quia laboriosam consequuntur odio, sed
            sint fuga nam.
          </p>
        </article>
        <h3 class="title">Векторная графика</h3>
        <img src="./images/raster-vs-vector.png" alt="" class="img" />
        <p>
          <b>SVG (Scalable Vector Graphics)</b> - формат графики и язык для
          описания векторных изображений. Внутри файл не бинарный, а обычный
          текст <b>(XML)</b>, описывающий объекты, их эффекты и поведение.
        </p>
        <p>Векторная графика имеет ряд преимуществ.</p>
        <ul>
          <li>
            <b>Масштабирование</b> - в отличие от растровой графики, SVG не
            теряет в качестве при масштабировании.
          </li>
          <li>
            <b>Размер файла</b> - векторные изображения весят намного меньше
            растровых, если используются для иконок или другой абстрактной
            графики. Использование вектора для фотореалестичных изображений
            наоборот ведёт к огромному размеру файла.
          </li>
          <li>
            <b>Динамичность</b> - при помощи CSS и JavaScript можно изменять
            параметры векторного изображения, например цвет или рамки.
          </li>
        </ul>
        <h3 class="title">SVG-элементы</h3>
        <p>
          Любое векторное изображение состоит из набора фигур, которые
          представлены SVG-элементами. Когда дизайнер экспортирует иконку из
          графического редактора, например Adobe Illustrator или Inkscape,
          программа переводит изображение в набор элементов и получается
          SVG-файл. Разработчик использует готовое SVG-изображение, не
          задумываясь о его содержимом, но базовое знакомство с элементами не
          будет лишним, поэтому рассмотрим некоторые из них.
        </p>
        <h3 class="title">Элемент &lt;svg&gt;</h3>
        <p>
          Определяет холст, на котором можно рисовать фигуры. Сделаем холст
          400x300 пикселей и добавим ему встроенный стиль с outline для
          визуализации границ.
        </p>
        <div class="bg">
          <p>index.html</p>
          <p>
            &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;
            outline: 2px dashed #2a2a2a;&quot;&gt;<br />
            &lt;!-- Тут будет разметка фигур --&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <h3 class="title">Элемент &lt;rect &gt;</h3>
        <p>
          Создаёт прямоугольную область. Нарисуем прямоугольник 250x150 пикселей
          и добавим следующие характеристики.
        </p>
        <ul>
          <li>Зальём цветом используя атрибут fill.</li>
          <li>
            Установим рамку чёрного цвета шириной в 4px атрибутами stroke и
            stroke-width.
          </li>
          <li>
            Зададим смещение 20px по вертикали и горизонтали относительно
            верхнего левого угла холста атрибутами x и y.
          </li>
          <li>
            Добавим скругление углов прямоугольника атрибутами rx (по
            горизонтали) и ry ( по вертикали). Если задать только одно значение,
            другое будет идентично.
          </li>
        </ul>
        <div class="bg">
          <p>index.html</p>
          <p>
            &lt;svg width=&quot;400&quot; height=&quot;300&quot;
            style=&quot;outline: 1px solid black;&quot;&gt; <br />
            &lt;rect <br />
            width=&quot;250&quot; <br />
            height=&quot;150&quot; <br />
            fill=&quot;tomato&quot; <br />
            stroke=&quot;black&quot; <br />
            stroke-width=&quot;4&quot; <br />
            x=&quot;20&quot; <br />
            y=&quot;20&quot; <br />
            rx=&quot;40&quot; <br />
            /&gt; <br />
            &lt;/svg&gt; <br />
          </p>
        </div>
        <p>
          Нарисуем еще один прямоугольник и разместим его в нижней правой части
          холста. Новая фигура перекроет первый прямоугольник, потому что фигуры
          располагаются как в слоёном пироге - ниже в разметке значит выше в
          слоях на холсте.
        </p>
        <svg width="400" height="300" style="outline: 2px dashed #2a2a2a">
          <rect
            width="250"
            height="150"
            fill="tomato"
            stroke="#2a2a2a"
            stroke-width="4"
            x="20"
            y="20"
            rx="40"
          />
          <rect
            width="250"
            height="150"
            fill="orange"
            stroke="#2a2a2a"
            stroke-width="4"
            x="120"
            y="120"
            rx="60"
            ry="30"
          />
        </svg>
        <h3 class="title">Элемент &lt;circle &gt;</h3>
        <p>
          Создаёт окружность, радиус которой задаётся атрибутом r. Нарисуем эту
          фигуру размером 100x100 пикселей, дадим ей рамку и зальём цветом.
          Получится окружность с центром в верхнем левом углу, большая часть
          которой скрыта, так как находится за холстом.
        </p>
        <div class="bg">
          <p>
            &lt;svg width=&quot;400&quot; height=&quot;300&quot;
            style=&quot;outline: 2px dashed #2a2a2a;&quot;&gt; <br />
            &lt;circle r=&quot;100&quot; fill=&quot;tomato&quot;
            stroke=&quot;#2a2a2a&quot; stroke-width=&quot;4&quot; /&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <p>
          Координаты центра окружности на холсте задаются атрибутами cx (center
          x) и cy (center y).
        </p>
        <svg width="400" height="300" style="outline: 2px dashed #2a2a2a">
          <circle
            r="100"
            cx="200"
            cy="150"
            fill="tomato"
            stroke="#2a2a2a"
            stroke-width="4"
          />
        </svg>
        <h3 class="title">Элемент &lt;ellipse &gt;</h3>
        <p>
          Создаёт элипс. Горизонтальный и вертикальный радиус задаётся
          атрибутами rx и ry. Остальные атрибуты совпадают с элементом
          &lt;circle &gt;. Нарисуем элипс 150x100 пикселей, дадим ему рамку и
          зальём цветом.
        </p>
        <svg width="400" height="300" style="outline: 2px dashed #2a2a2a">
          <ellipse
            rx="150"
            ry="100"
            cx="200"
            cy="150"
            fill="tomato"
            stroke="#2a2a2a"
            stroke-width="4"
          />
        </svg>
        <h3 class="title">Элемент &lt;line &gt;</h3>
        <p>
          Создаёт прямую линию. Атрибуты x1 и y1 указывают точку начала линии, а
          x2 и y2 её конец. Нарисуем на холсте иконку гамбургер-меню из трёх
          паралельных горизонтальных линий.
        </p>
        <div class="bg">
          <p>
            &lt;svg width=&quot;400&quot; height=&quot;300&quot;
            style=&quot;outline: 2px dashed #2a2a2a;&quot;&gt; <br />
            &lt;line x1=&quot;20&quot; y1=&quot;50&quot; x2=&quot;380&quot;
            y2=&quot;50&quot; stroke=&quot;#2a2a2a&quot;
            stroke-width=&quot;16&quot; /&gt; <br />
            &lt;line x1=&quot;20&quot; y1=&quot;80&quot; x2=&quot;380&quot;
            y2=&quot;80&quot; stroke=&quot;#2a2a2a&quot;
            stroke-width=&quot;16&quot; /&gt; <br />
            &lt;line x1=&quot;20&quot; y1=&quot;110&quot; x2=&quot;380&quot;
            y2=&quot;110&quot; stroke=&quot;#2a2a2a&quot;
            stroke-width=&quot;16&quot; /&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <svg width="400" height="165" style="outline: 2px dashed #2a2a2a">
          <line
            x1="20"
            y1="50"
            x2="380"
            y2="50"
            stroke="#2a2a2a"
            stroke-width="16"
          />
          <line
            x1="20"
            y1="80"
            x2="380"
            y2="80"
            stroke="#2a2a2a"
            stroke-width="16"
          />
          <line
            x1="20"
            y1="110"
            x2="380"
            y2="110"
            stroke="#2a2a2a"
            stroke-width="16"
          />
        </svg>
        <h3 class="title">Элемент &lt;polygon &gt;</h3>
        <p>
          Описывает многоугольник, вид которого определяется атрибутом points -
          набором точек в виде координат линий, которые разделены на группы.
        </p>

        <div class="bg">
          <p>
            &lt;svg width=&quot;600&quot; height=&quot;300&quot;
            style=&quot;outline: 2px dashed #2a2a2a;&quot;&gt; <br />
            &lt;polygon <br />
            points=&quot;20,20 20,200 200,200 200,20&quot; <br />
            fill=&quot;orange&quot; <br />
            stroke=&quot;#2a2a2a&quot; <br />
            stroke-width=&quot;4&quot; <br />
            /&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <p>
          Первая цифра группы - координата x, вторая цифра после запятой –
          координата y. Первая группа цифр определяет координаты начала первой
          линии, вторая группа определяет конец первой линии и одновременно
          начало второй линии и т. д. Полигон это замкнутая фигура, поэтому
          последняя замыкающая линия добавляется автоматически, соединяя конец
          последней линии с началом первой линии фигуры.
        </p>
        <svg width="600" height="300" style="outline: 2px dashed #2a2a2a">
          <!-- Квадрат -->
          <polygon
            points="20,20 20,200 200,200 200,20"
            fill="orange"
            stroke="#2a2a2a"
            stroke-width="4"
          />

          <!-- Трехугольник -->
          <polygon
            points="250,20 250,200 400,200"
            fill="skyblue"
            stroke="#2a2a2a"
            stroke-width="4"
          />

          <!-- Параллелограмм -->
          <polygon
            points="430,20 430,200 550,250 550, 70"
            fill="palevioletred"
            stroke="#2a2a2a"
            stroke-width="4"
          />
        </svg>
        <h3 class="title">Элемент &lt;path &gt;</h3>
        <p>
          Универсальный элемент для представления фигур любой сложности. Все
          SVG-иконки, экспортируемые дизайнером, описаны этим элементом. Атрибут
          d содержит набор координат и соединяющих их кривых, определяющих
          направление линий. Вручную редакторивать path не нужно. Иконки
          рисуются в специальных редакторах, которые при экспорте заполняют path
          и другие элементы и их атрибуты.
        </p>
        <svg
          viewBox="0 -10 511.991 511"
          xmlns="http://www.w3.org/2000/svg"
          width="300"
          height="300"
          style="outline: 2px dashed #2a2a1a"
        >
          <path
            d="M510.652 185.883a27.177 27.177 0 00-23.402-18.688l-147.797-13.418-58.41-136.75C276.73 6.98 266.918.497 255.996.497s-20.738 6.483-25.023 16.53l-58.41 136.75-147.82 13.418c-10.837 1-20.013 8.34-23.403 18.688a27.25 27.25 0 007.937 28.926L121 312.773 88.059 457.86c-2.41 10.668 1.73 21.7 10.582 28.098a27.087 27.087 0 0015.957 5.184 27.14 27.14 0 0013.953-3.86l127.445-76.203 127.422 76.203a27.197 27.197 0 0029.934-1.324c8.851-6.398 12.992-17.43 10.582-28.098l-32.942-145.086 111.723-97.964a27.246 27.246 0 007.937-28.926zM258.45 409.605"
            fill="#2a2a2a"
          />
        </svg>

        <h3 class="title">SVG-документ</h3>
        <p>
          Векторную графику хранят в файлах с расширением .svg. Это обычные
          текстовые файлы, в которых на верхнем уровне находится тег &lt;svg&gt;
          с набором служебных атрибутов, указывающих в какой версии языка
          разметки и согласно какой версии SVG-спецификации написан документ. Из
          всех служебных только атрибут xmlns является обязательным, остальные
          обычно пропускают.
        </p>
        <div class="bg">
          <p>
            &lt;svg <br />
            version=&quot;1.1&quot; <br />
            xmlns=&quot;http://www.w3.org/2000/svg&quot; <br />
            xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; <br />
            xmlns:ev=&quot;http://www.w3.org/2001/xml-events&quot; <br />
            &gt; <br />
            &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
            <br />
            fill=&quot;tomato&quot; /&gt; &lt;/svg&gt; <br />
          </p>
        </div>
        <p>
          Если сохранить этот код во внешнем файле, например icon.svg, и
          добавить на веб-страницу используя тег &lt;img&gt;, браузер нарисует
          холст 300x150 пикселей в центре которого будет окружность.
        </p>
        <p class="information">
          Если явно не задать размер, браузер по умолчанию устанавливает размер
          элемента 300x150 пикселей. Всё что не поместилось - обрежется.
        </p>
        <h3 class="title">SVG-viewport</h3>
        <p>
          Содержимое SVG-документа отрисовывается на бесконечном холсте и может
          быть сколь угодно большого размера, но видимая часть холста
          соответствует размерам элемента &lt;svg&gt;. Атрибуты width и height
          задают размер рабочей области просмотра (viewport). Верхний левый угол
          области просмотра это начало координат, где x = 0 и y = 0. По
          умолчанию используются пиксели, поэтому указание px излишне.
        </p>
        <div class="bg">
          <p>
            &lt;svg <br />
            xmlns=&quot;http://www.w3.org/2000/svg&quot; <br />
            width=&quot;400&quot; <br />
            height=&quot;200&quot; <br />
            style=&quot;outline: 2px dashed #2a2a2a;&quot;<br />
            &gt;<br />
            &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
            fill=&quot;tomato&quot; /&gt; <br />
            &lt;/svg&gt;
          </p>
        </div>
        <h3 class="title">SVG-viewBox</h3>
        <p>
          Если перевести «view box», то буквально получим «окно просмотра». То
          есть, это «окно», через которое можно просматривать некоторую часть
          SVG-документа. Чем-то похоже на окно иллюминатора в самолёте, через
          которое вы можете видеть окружающий мир, но viewBox также может
          масштабировать (приближать или отдалять) картинку, как телескоп.
        </p>
        <img src="./images/viewbox.svg" alt="" />
        <p>
          Атрибут viewBox определяет какая часть изображения будет отображена, и
          в каком масштабе.
        </p>
        <p class="bg">viewBox="x y width height"</p>

        <div>
          <p class="bg">&lt;svg viewBox=&quot;0 0 400 200&quot;&gt;</p>
          <svg
            class="vector"
            xmlns="http://www.w3.org/2000/svg"
            width="200"
            height="200"
            viewBox="0 0 400 200"
            style="outline: 2px dashed #2a2a2a"
          >
            <circle r="75" cx="50%" cy="50%" fill="tomato" />
          </svg>
        </div>
        <p>
          Если соотношение значений атрибутов width и height к их аналогам у
          viewBox равно 1:1, изображение будет отрисовано в оригинальном
          размере.
        </p>
        <p class="bg">
          &lt;svg width=&quot;400&quot; height=&quot;200&quot; viewBox=&quot;0 0
          400 200&quot;&gt; <br />
          &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
          fill=&quot;tomato&quot; /&gt; <br />
          &lt;/svg&gt;
        </p>
        <p>
          При соотношении 2:1, оригинальное изображение будет увеличено в
          масштабе ровно в два раза, но размеры элемента останутся прежними -
          400x200.
        </p>
        <p class="bg">
          &lt;svg width=&quot;400&quot; height=&quot;200&quot; viewBox=&quot;0 0
          200 100&quot;&gt; <br />
          &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
          fill=&quot;tomato&quot; /&gt; <br />
          &lt;/svg&gt;
        </p>
        <p>
          При соотношении 1:2, оригинальное изображение будет уменьшено в
          масштабе ровно в два раза, но размеры элемента останутся прежними -
          400x200.
        </p>
        <p class="bg">
          &lt;svg width=&quot;400&quot; height=&quot;200&quot; viewBox=&quot;0 0
          800 400&quot;&gt; <br />
          &lt;circle r=&quot;75&quot; cx=&quot;50%&quot; cy=&quot;50%&quot;
          fill=&quot;tomato&quot; /&gt; <br />
          &lt;/svg&gt;
        </p>
        <p class="warning">
          То есть viewBox это «окно», через которое пользователь смотрит на
          SVG-документ. Оно может быть перемещено в любое место SVG-документа, и
          пользователь увидит фрагмент, который находится непосредственно под
          viewBox, согласно заданному масштабу.
        </p>
        <h3 class="title">Использование</h3>
        <p>
          Есть несколько способов использования векторной графики, каждый имеет
          свои плюсы и минусы.
        </p>
        <h4 class="title">В элементе &lt;img&gt;</h4>
        <p>
          Такой подход ничем не отличается от использования растровых
          изображений, достаточно указать путь к изображению. Создадим три
          элемента <img /> разных размеров и используем одну и ту же SVG-иконку.
          Пикселизации нет даже если максимально масштабировать веб-страницу,
          потому что в элементе <img /> вектор также рисуется браузером по
          заданым формулам внутри SVG-файла.
        </p>
        <div class="bg">
          <img
            src="https://res.cloudinary.com/goit-academy/image/upload/v1614773221/codepen/cat_segyum.svg"
            width="60"
          />
          <img
            src="https://res.cloudinary.com/goit-academy/image/upload/v1614773221/codepen/cat_segyum.svg"
            width="120"
          />
          <img
            src="https://res.cloudinary.com/goit-academy/image/upload/v1614773221/codepen/cat_segyum.svg"
            width="180"
          />
        </div>
        <h3 class="title">Как фон элемента</h3>
        <p>
          Векторное изображение может использоваться как фон элемента в свойстве
          background-image. Можно делать любые манипуляции с векторным фоном,
          так же как и с растровой графикой.
        </p>
        <div class="box"></div>

        <h3 class="title">Встроенный SVG</h3>
        <p>
          Предыдущие два метода подходят для статической графики, например
          абстрактного фона или иконок, для которых не нужно добавлять эффект
          ховера или фокуса. Но у них есть один существенный недостаток - нет
          возможности динамичекски изменить цвет или другие характеристики
          векторного изображения из CSS. SVG-изображение можно добавить целиком
          в HTML, это называется встроенный SVG (inline svg). То есть, открыть
          SVG-файл в текстовом редакторе, скопировать содержимое и вставить его
          в HTML-документ. Так можно обратиться к его внутренней структуре. В
          примере мы добавляем элементу &lt;svg&gt; класс .icon, устанавливаем
          базовый чёрный цвет заливки (свойство fill) и меняем его при ховере на
          оранжевый.
        </p>

        <p>У такого подхода есть ряд существенных минусов.</p>
        <ul>
          <li>Встроенный SVG-код увеличивает размер HTML-файла.</li>
          <li>
            Невозможно повторно использовать одно и то же изображение без
            дублирования кода.
          </li>
          <li>Поддержка и правки встроенного SVG трудозатратны.</li>
          <li>
            Браузер не может кэшировать встроенные фигуры, в отличии от внешних
            SVG-файлов.
          </li>
        </ul>

        <h3 class="title">SVG-спрайт</h3>
        <p>
          SVG-спрайт это современная техника, которую применяют в большинстве
          случаев.
        </p>
        <ul>
          <li>Один файл для всех SVG-иконок веб-сайта.</li>
          <li>
            Файл спрайта кешируется браузером и не будет загружен при повторных
            посещениях.
          </li>
          <li>
            Иконкам в спрайте можно изменять цвет и другие характеристики через
            CSS.
          </li>
        </ul>
        <p class="information">
          Создание SVG-спрайта, используя сервис icomoon.io, рассматривается в
          видео-лекции.
        </p>
        <br />
        <p>
          SVG-документ это просто текстовый файл, внутри которого, в отличие от
          растровой графики, описаны фигуры, которые отрисует браузер. Внутри
          одного файла можно описать множество разных групп фигур используя
          элемент &lt;symbol&gt;, после чего, дав каждому символу уникальный id,
          обратиться к любому из них из HTML-документа.
        </p>
        <p class="bg">
          index.html <br />
          &lt;svg&gt; <br />
          &lt;use
          href=&quot;./путь-к-свг-спрайту/имя-спрайта.svg#идентификатор-символа&quot;&gt;&lt;/use&gt;
          <br />
          &lt;/svg&gt;
        </p>
        <p>
          Для использования иконки из спрайта в HTML-документе необходимо
          добавить разметку элемента &lt;svg&gt; и вложенного в него элемента
          &lt;use&gt; с атрибутом href, в котором указан путь к иконке. Путь
          задаётся как к обычному файлу, но в конце добавляется якорь с
          идентификатором символа в спрайте. Разберём пример. Для наглядности мы
          вставили весь SVG-спрайт в документ (и задав ему id, спрятали), чтобы
          сэкономить вам время перехода поиска SVG-кода (ведь интересно как он
          там внутри устроен).
        </p>
        <div class="bg">
          <svg
            aria-hidden="true"
            style="position: absolute; width: 0; height: 0"
            xmlns="http://www.w3.org/2000/svg"
            overflow="hidden"
          >
            <defs>
              <!-- Trash can icon -->
              <symbol id="delete" viewBox="0 0 32 32">
                <path
                  d="M8 25.333C8 26.8 9.2 28 10.667 28h10.667c1.467 0 2.667-1.2 2.667-2.667v-16h-16v16zm17.333-20h-4.667L19.333 4h-6.667l-1.333 1.333H6.666V8h18.667V5.333z"
                />
              </symbol>
              <!-- Camera icon -->
              <symbol id="camera" viewBox="0 0 32 32">
                <path
                  d="M20.267 16a4.267 4.267 0 11-8.534 0 4.267 4.267 0 018.534 0z"
                />
                <path
                  d="M12 2.667L9.56 5.334H5.333a2.675 2.675 0 00-2.667 2.667v16c0 1.467 1.2 2.667 2.667 2.667h21.333c1.467 0 2.667-1.2 2.667-2.667v-16c0-1.467-1.2-2.667-2.667-2.667h-4.227l-2.44-2.667h-8zm4 20c-3.68 0-6.667-2.987-6.667-6.667S12.32 9.333 16 9.333 22.667 12.32 22.667 16 19.68 22.667 16 22.667z"
                />
              </symbol>
              <!-- Portfolio icon -->
              <symbol id="work" viewBox="0 0 32 32">
                <path
                  d="M26.667 8h-5.333V5.333a2.658 2.658 0 00-2.667-2.667h-5.333a2.658 2.658 0 00-2.667 2.667V8H5.334a2.646 2.646 0 00-2.653 2.667l-.013 14.667a2.658 2.658 0 002.667 2.667h21.333a2.658 2.658 0 002.667-2.667V10.667A2.658 2.658 0 0026.668 8zm-8 0h-5.333V5.333h5.333V8z"
                />
              </symbol>
            </defs>
          </svg>

          <ul class="icon-list">
            <li>
              <svg class="icon" width="80" height="80">
                <use href="#delete"></use>
              </svg>
            </li>
            <li>
              <svg class="icon" width="80" height="80">
                <use href="#camera"></use>
              </svg>
            </li>
            <li>
              <svg class="icon" width="80" height="80">
                <use href="#work"></use>
              </svg>
            </li>
          </ul>
        </div>
        <p>
          Итак, внутри SVG-спрайта есть набор элементов &lt;svg&gt; и
          &lt;symbol&gt;, описывающих весь SVG-спрайт целиком и каждую фигуру по
          отдельности. Каждому &lt;symbol&gt; задан уникальный идентификатор. В
          HTML используем атрибут href и обращаемся к SVG-символу через хеш (#)
          и его идентификатор.
        </p>
        <p class="warning">
          В примере весь SVG-спрайт находится в HTML-разметке, поэтому нет имени
          SVG-файла перед хешем. Если бы SVG-спрайт лежал отдельным файлом, было
          бы обращение по имени, а потом # и id символа.
        </p>
        <br />
        <div class="bg">
          <svg class="icon" width="60" height="30">
            <use href="./images/icons.svg#delete"></use>
          </svg>
          <svg class="icon" width="60" height="30">
            <use href="./images/icons.svg#camera"></use>
          </svg>
          <svg class="icon" width="60" height="30">
            <use href="./images/icons.svg#work"></use>
          </svg>
        </div>
        <br />
        <p class="bg">
          &lt;div&gt; <br />
          &lt;svg class=&quot;icon&quot; width=&quot;60&quot;
          height=&quot;30&quot;&gt; <br />
          &lt;use href=&quot;./images/icons.svg#delete&quot;&gt;&lt;/use&gt;
          <br />
          &lt;/svg&gt; <br />
          &lt;svg class=&quot;icon&quot; width=&quot;60&quot;
          height=&quot;30&quot;&gt; <br />
          &lt;use href=&quot;./images/icons.svg#camera&quot;&gt;&lt;/use&gt;
          <br />
          &lt;/svg&gt; <br />
          &lt;svg class=&quot;icon&quot; width=&quot;60&quot;
          height=&quot;30&quot;&gt; <br />
          &lt;use href=&quot;./images/icons.svg#work&quot;&gt;&lt;/use&gt;
          <br />
          &lt;/svg&gt; <br />
          &lt;/div&gt;
        </p>

        <p>to be continiue</p>

        <h3 class="title">Оформление фигур</h3>
        <p>
          В CSS можно динамически изменять некоторые характеристики встроенного
          векторного изображения или иконки из SVG-спрайта, например заливку,
          цвет или тип обводки. Значения можно задавать как атрибутами
          SVG-фигур, так и одноимёнными CSS-свойствами. На практике для
          оформления фигур используют не атрибуты, а CSS-код, так как его проще
          поддерживать и изменять.
        </p>
        <h3 class="title">Свойство fill</h3>
        <p>
          Управляет цветом заливки. Цвет можно задавать в любом удобном формате.
          Если цвет заливки не указан, фигура будет залита текущим цветом
          текста, по умолчанию чёрным (#000000). Полностью убрать заливку можно
          значением none, в результате получится полностью прозрачная фигура.
        </p>
        <p class="bg">
          /* Устанавливаем цвет заливки в спокойном состоянии. */ <br />
          .icon { <br />
          fill: #2a2a2a; <br />
          } <br />
          <br />

          /* Изменяем цвет заливки при ховере. */ <br />
          .icon:hover { <br />
          fill: #ff6347; <br />
          }
        </p>
        <h3 class="title">Свойство fill-opacity</h3>
        <p>
          Управляет только прозрачностью цвета заливки, а не всего цвета или
          элемента, то есть отличается от opacity или stroke-opacity. Например,
          если у иконки будет задана красная обводка, то на её цвет это свойство
          не повлияет. Значение задаётся числом от 0 до 1.
        </p>
        <p class="bg">
          .icon { <br />
          fill: #2a2a2a; <br />
          fill-opacity: 0.7; <br />
          } <br />
          <br />

          /* fill-opacity также применится к новому цвету при ховере. */ <br />
          .icon:hover { <br />
          fill: #03a9f4; <br />
          }
        </p>
        <h3 class="title">Свойство stroke</h3>
        <p>
          Устанавливает цвет обводки. По умолчанию не имеет значения.
          Характеристики обводки, например цвет и толщина, задаются отдельными
          свойствами.
        </p>
        <p class="bg">
          .icon { <br />
          stroke: #f44336; <br />
          }
        </p>

        <h3 class="title">Свойство stroke-width</h3>
        <p>
          Контролирует толщину обводки. Значение по умолчанию 1px, поэтому для
          однопиксельной обводки достаточно указать цвет в свойстве stroke. Если
          задана толщина обводки, но не задан цвет, она не отобразится.
        </p>
        <p class="bg">
          .icon { <br />
          stroke: #f44336; <br />
          stroke-width: 3px; <br />
          }
        </p>
        <h3 class="title">Свойство stroke-opacity</h3>
        <p>
          Управляет только прозрачностью цвета обводки, а не всего цвета или
          элемента. Значение задаётся числом от 0 до 1.
        </p>
        <p class="bg">
          .icon { <br />
          stroke: #f44336; <br />
          stroke-width: 3px; <br />
          stroke-opacity: 0.7; <br />
          }
        </p>

        <h3 class="title">Декоративный оверлей</h3>
        Свойство <b>overflow</b> со значением <b>hidden</b> используется при
        создании декоративных эффектов с появлением скрытого контента из-за
        границ блока.
        <h1>Наведи курсор мыши на квадрат</h1>

        <div class="box">
          <div class="box__overlay">
            <p>
              Это содержимое скрыто посредством трансформации и появляется
              только при наведении курсора на <code>.box__overlay</code>
            </p>
          </div>
        </div>
        <p>
          Такой эффект реализуется в несколько простых шагов. Разберём стили для
          создания эффекта, полный код смотрите в живом примере.
        </p>
        <p class="bg">
          &lt;div class=&quot;box&quot;&gt; <br />
          &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; <br />
          &lt;/div&gt;
        </p>
        <p>
          Вначале абсолютно позиционируем <b>div.box__overlay</b> относительно
          <b>div.box</b> и растягиваем его на всю ширину и высоту
          <b>div.box</b>.
        </p>
        <p class="bg">
          .box { <br />
          position: relative; <br />
          } <br /><br />

          .overlay {<br />
          position: absolute;<br />
          top: 0;<br />
          left: 0;<br />
          width: 100%;<br />
          height: 100%;<br />
          }
        </p>
        <p class="bg">
          Используя свойство <b>transform</b> и <b>translateX</b>, смещаем
          <b>div.box__overlay</b> влево на <b>100%</b> его ширины. Трансформации
          будем детально рассматривать дальше.
        </p>
        <p class="bg">
          .box__overlay { <br />
          position: absolute; <br />
          top: 0;<br />
          left: 0;<br />
          width: 100%;<br />
          height: 100%;<br />

          transform: translateX(-100%);<br />
          }
        </p>
        <p>
          При ховере по <b>div.box</b>, используя <b>transform</b> и
          <b>translateX</b>, возвращаем <b>div.box__overlay</b> в исходное
          положение.
        </p>
        <p class="bg">
          .box:hover .box__overlay { <br />
          transform: translateX(0); <br />
          }
        </p>
        <p>
          Задаём <b>div.box</b> свойство <b>overflow</b> со значением
          <b>hidden</b>, чтобы визуально спрятать <b>div.box__overlay</b>, когда
          тот смещён за пределы <b>div.box</b>.
        </p>
        <p class="bg">
          .box { <br />
          position: relative; <br />
          overflow: hidden; <br />
          }
        </p>
        <p>
          Cейчас просто используем одно свойство для визуализации появления
          оверлея. Добавляем <b>div.box__overlay</b> переход для анимации
          свойства <b>transform</b>.
        </p>
        <p class="bg">
          .box__overlay { <br />
          position: absolute;<br />
          top: 0;<br />
          left: 0;<br />
          width: 100%;<br />
          height: 100%;<br />

          transform: translateX(-100%);<br />
          transition: transform 250ms ease;<br />
          }
        </p>
      </div>
    </header>
    <script src="./js/script.js"></script>
  </body>
</html>
